#!/bin/sh

. "$SPEC_PATH/abstract/backup"

e2e_test_extra_hash() {
  "$SHELL" "$PROJECT_PATH/stackgres-k8s/ci/build/build-functions.sh" path_hash \
    "$(realpath --relative-to "$PROJECT_PATH" "$SPEC_PATH/abstract/backup")"
}

e2e_test_install() {
  STREAM_NAME="$(get_sgstreams_name "$SPEC_NAME-operation")"
  TARGET_CLUSTER_NAME="$(get_sgstreams_name "$SPEC_NAME-target")"

  install_minio

  create_or_replace_cluster "$CLUSTER_NAME" "$CLUSTER_NAMESPACE" 1
  create_or_replace_cluster "$TARGET_CLUSTER_NAME" "$CLUSTER_NAMESPACE" 1 \
    --set configurations.create=false \
    --set instanceProfiles=null

  deploy_curl_pod "$CLUSTER_NAMESPACE"

  wait_pods_running "$CLUSTER_NAMESPACE" 4
  wait_cluster "$CLUSTER_NAME" "$CLUSTER_NAMESPACE"
}

e2e_test() {
  run_test "Checking that stream is working" check_stream_is_working
}

check_stream_is_working() {
  cat << 'EOF' | tee "$LOG_PATH/init-tables.sql" | kubectl exec -i -n "$CLUSTER_NAMESPACE" "$CLUSTER_NAME-0" -c postgres-util -- psql -v ON_ERROR_STOP=on
CREATE TABLE test(i bigint, PRIMARY KEY(i));

INSERT INTO test SELECT * FROM generate_series(1, 3);

DO $$BEGIN
EXECUTE 'CREATE FUNCTION create_complex_table() RETURNS void AS $sql$CREATE TABLE complex(i bigint,'
  || (SELECT string_agg(col_def, ', ') FROM (
    SELECT quote_ident('c_' || t.typname) || ' ' || pg_catalog.format_type(t.oid, NULL) AS col_def
  FROM pg_catalog.pg_type t LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
  WHERE (t.typrelid = 0 OR (SELECT c.relkind = 'c' FROM pg_catalog.pg_class c WHERE c.oid = t.typrelid))
  AND NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type el WHERE el.oid = t.typelem AND el.typarray = t.oid)
  AND pg_catalog.pg_type_is_visible(t.oid)
  AND t.typtype NOT IN ('p')
  AND t.typcategory NOT IN ('U','Z')
  ORDER BY t.typname)) || ', PRIMARY KEY (i))' || '$sql$ LANGUAGE sql';
END$$;

DO $$BEGIN
EXECUTE 'CREATE FUNCTION insert_complex(i bigint) RETURNS void LANGUAGE plpgsql AS $plpgsql$BEGIN EXECUTE $insert$INSERT INTO complex SELECT $insert$ || i || $insert$, '
    || (SELECT string_agg(col_def, ', ')
      FROM (
        SELECT (
          CASE
            WHEN t.typcategory IN ('I') THEN '''1.2.3.4'''
            WHEN t.typcategory IN ('D') THEN '''' || NOW() || ''''
            WHEN t.typname = 'datemultirange' THEN '''{(,)}'''
            WHEN t.typname = 'daterange' THEN '''(,)'''
            WHEN t.typname = 'int4multirange' THEN '''{[1,2), [3,4)}'''
            WHEN t.typname = 'int4range' THEN '''[2,4)'''
            WHEN t.typname = 'int8multirange' THEN '''{[4,12)}'''
            WHEN t.typname = 'int8range' THEN '''(3,7)'''
            WHEN t.typname = 'nummultirange' THEN '''{[1.1,2.2)}'''
            WHEN t.typname = 'numrange' THEN '''(1.1,2.2)'''
            WHEN t.typname IN ('tsmultirange', 'tstzmultirange') THEN '''{[2011-01-01,2011-03-01)}'''
            WHEN t.typname IN ('tsrange', 'tstzrange') THEN '''[2011-01-01,2011-03-01)'''
            WHEN t.typname = 'dblink_pkey_results' THEN '''(1,2)'''
            WHEN t.typname = 'line' THEN '''{1,2,3}'''
            WHEN t.typname = 'point' THEN '''(1,2)'''
            WHEN t.typname = 'circle' THEN '''<(1,2),3>'''
            WHEN t.typname IN ('lseg','box','path','polygon') THEN '''((1,2),(3,4))'''
            WHEN t.typcategory IN ('Z') THEN '''t'''
            WHEN t.typtype IN ('r','m') OR t.typcategory IN ('A') THEN 'array[]'
            WHEN t.typcategory IN ('N','V','T') THEN '''1'''
            ELSE '''t''' END)
    || '::' || pg_catalog.format_type(t.oid, NULL) AS col_def
  FROM pg_catalog.pg_type t LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
  WHERE (t.typrelid = 0 OR (SELECT c.relkind = 'c' FROM pg_catalog.pg_class c WHERE c.oid = t.typrelid))
  AND NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type el WHERE el.oid = t.typelem AND el.typarray = t.oid)
  AND pg_catalog.pg_type_is_visible(t.oid)
  AND t.typtype NOT IN ('p')
  AND t.typcategory NOT IN ('U','Z')
  ORDER BY t.typname)) || '$insert$; END$plpgsql$;';
END$$;

-- SELECT create_complex_table();
-- SELECT insert_complex(i) FROM generate_series(1, 3) AS i; 
EOF

  cat << EOF | tee "$LOG_PATH/sgstream-working.yaml" | kubectl create -f -
apiVersion: stackgres.io/v1alpha1
kind: SGStream
metadata:
  namespace: $CLUSTER_NAMESPACE 
  name: "$STREAM_NAME"
spec:
  maxRetries: 0
  source:
    type: SGCluster
    sgCluster:
      name: "$CLUSTER_NAME"
      debeziumProperties:
        includeUnknownDatatypes: true
        columnPropagateSourceType: [.*]
        datatypePropagateSourceType: [.*]
  target:
    type: SGCluster
    sgCluster:
      name: "$TARGET_CLUSTER_NAME"
      debeziumProperties:
        schemaEvolution: basic
        quoteIdentifiers: true
  pods:
    persistentVolume:
      size: 1Gi
  debeziumEngineProperties:
EOF

  if wait_until eval 'kubectl get sgstream -n "$CLUSTER_NAMESPACE" "$STREAM_NAME" -o json | jq .status.snapshot.snapshotCompleted | grep -qxF true'
  then
    echo "SUCCESS: snapshot completed"
  else
    echo "FAIL: snapshot did not completed"
    return 1
  fi

  if kubectl get sgstream -n "$CLUSTER_NAMESPACE" "$STREAM_NAME" -o json | jq '.status.snapshot.rowsScanned["public.test"]' | grep -qxF 3
  then
    echo "SUCCESS: test table scanned"
  else
    echo "FAIL: test table not scanned"
    return 1
  fi

  # if kubectl get sgstream -n "$CLUSTER_NAMESPACE" "$STREAM_NAME" -o json | jq '.status.snapshot.rowsScanned["public.complex"]' | grep -qxF 3
  # then
  #   echo "SUCCESS: complex table scanned"
  # else
  #   echo "FAIL: complex table not scanned"
  #   return 1
  # fi

  cat << 'EOF' | tee "$LOG_PATH/insert-tables.sql" | kubectl exec -i -n "$CLUSTER_NAMESPACE" "$CLUSTER_NAME-0" -c postgres-util -- psql -v ON_ERROR_STOP=on
INSERT INTO test SELECT * FROM generate_series(4, 6);

-- SELECT insert_complex(i) FROM generate_series(4, 6) AS i; 
EOF

  if wait_until eval 'kubectl get sgstream -n "$CLUSTER_NAMESPACE" "$STREAM_NAME" -o json | jq .status.streaming.connected | grep -qxF true'
  then
    echo "SUCCESS: streaming started"
  else
    echo "FAIL: streaming not started"
    return 1
  fi

  if wait_until eval 'kubectl get sgstream -n "$CLUSTER_NAMESPACE" "$STREAM_NAME" -o json | jq .status.streaming.numberOfCommittedTransactions | grep -qxF 2'
  then
    echo "SUCCESS: streaming transaction successful"
  else
    echo "FAIL: streaming transaction failed"
    return 1
  fi

  if wait_until eval 'kubectl get sgstream -n "$CLUSTER_NAMESPACE" "$STREAM_NAME" -o json | jq '.status.streaming.totalNumberOfCreateEventsSeen' | grep -qxF 3' # 6'
  then
    echo "SUCCESS: streaming events successful"
  else
    echo "FAIL: streaming events failed"
    return 1
  fi

  if kubectl get sgstream -n "$CLUSTER_NAMESPACE" "$STREAM_NAME" -o json | jq '.status.events.totalNumberOfEventsSent' | grep -qxF 6 # 12
  then
    echo "SUCCESS: sent events successful"
  else
    echo "FAIL: sent events failed"
    return 1
  fi

  if kubectl get sgstream -n "$CLUSTER_NAMESPACE" "$STREAM_NAME" -o json | jq '.status.events.lastEventWasSent' | grep -qxF true
  then
    echo "SUCCESS: sent last event successful"
  else
    echo "FAIL: sent last event failed"
    return 1
  fi
}
